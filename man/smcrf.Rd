% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/smcrf.r
\name{smcrf}
\alias{smcrf}
\title{Approximate Bayesian Computation sequential Monte Carlo via random forests}
\usage{
smcrf(
  method = "smcrf-single-param",
  statistics_target = NULL,
  smcrf_results = NULL,
  model,
  perturb,
  bounds = NULL,
  parameters_initial = NULL,
  nParticles,
  parallel = FALSE,
  n_cores = NULL,
  ...
)
}
\arguments{
\item{method}{Random forest method to implement in each iteration ("smcrf-single-param" by default).
method = "smcrf-single-param": implements ABC-RF for each parameter and results in their marginal posterior distributions.
method = "smcrf-multi-param": implements ABC-DRF for all parameters and results in the joint posterior distribution.}

\item{statistics_target}{A dataframe containing statistics from data.
Column names are the statistics IDs.
`smcrf()` only supports one row of statistics.
If there are multiple observations, we recommend applying `smcrf()` to each row individually.}

\item{smcrf_results}{An existing ABC-SMC-RF result.
If provided, smcrf will continue ABC-SMC-RF from the last iteration of the previous run.}

\item{model}{Model for the statistics.
The function must take two inputs: a data frame parameters and logic variable parallel.
The model will output a reference table.
Each row contains parameters for each simulation and corresponding statistics.}

\item{perturb}{A choice of kernel function that perturbs parameters for ABC-SMC-RF in each iteration.
If perturb is a specified perturbation kernel function, each parameter follows the perturb function.}

\item{bounds}{A dataframe containing bounds for each parameter.
Usually no larger than the bounds of prior distribution.}

\item{parameters_initial}{A dataframe containing the initial guess for parameters.
Each column represents the prior distribution for corresponding parameter.}

\item{nParticles}{A list of numbers showing the particles of ABC-SMC-RF.
Each entry indicates the number of simulations in the corresponding iteration.}

\item{parallel}{A logic variable (parallel = FALSE by default).
If parallel = TRUE, the ABC-RF functions will be computed in parallel.}

\item{n_cores}{Number of cores in used in parallel computation.
When default with n_cores = NULL, the parallel function will use maximum number of available cores.}

\item{...}{Additional arguments to be passed to `abcrf` or `drf`.}
}
\value{
An object `smcrf_results` containing the results of the inference.
If the posterior distributions have not converged to a satisfactory level,
the user may continue with `smcrf(smcrf_results = smcrf_results, ...)`,
in which case ABC-SMC-(D)RF will continue iterating from the last run in `smcrf_results`.
}
\description{
`smcrf()` uses random forests to find the posterior distribution(s) for one or more parameters in a model.
It implements the sequential Monte Carlo framework, where each iteration
uses either ABC-RF (functions `regAbcrf` and `predict` in R package `abcrf`)
or ABC-DRF (functions `drf` and `predict` in R package `drf`) to update the posterior distribution(s).
}
\examples{
library(abcsmcrf)
#---------------------------ABC-SMC-RF for a model with one parameter
# Data to be fitted consists of two statistics s1 and s2
statistics_target <- data.frame(s1 = 0, s2 = 2)
# We then define a parametrized model for the statistics
model <- function(parameters) {
    statistics <- data.frame(
        s1 = parameters$theta - 1 + runif(nrow(parameters), -0.1, 0.1),
        s2 = parameters$theta + 1 + runif(nrow(parameters), -0.1, 0.1)
    )
    cbind(parameters, statistics)
}
# and a function to perturb the parameters with random noise between iterations
perturb <- function(parameters) {
    parameters$theta <- parameters$theta + runif(nrow(parameters), min = -0.1, max = 0.1)
    return(parameters)
}
# We start from initial guesses for theta from Uniform(-10, 10)
parameters_initial <- data.frame(theta = runif(100000, -10, 10))
# while ensuring that theta stays within bounds
bounds <- data.frame(
    parameter = c("theta"),
    min = c(-10),
    max = c(10)
)
# Finally, we run ABC-SMC-RF with 2 iterations, each with 1000 particles
smcrf_results <- smcrf(
    method = "smcrf-single-param",
    statistics_target = statistics_target,
    model = model,
    perturb = perturb,
    bounds = bounds,
    parameters_initial = parameters_initial,
    nParticles = c(1000, 1000),
)
# Now we examine the posterior distribution of theta
posterior_iteration <- paste0("Iteration_", (smcrf_results$nIterations + 1))
posterior_theta <- smcrf_results[[posterior_iteration]]$parameters$theta
# We look at the posterior mean of theta
theta_mean <- mean(posterior_theta)
print(theta_mean)
# Notice that the mean is close to 1, the true value of theta.
# We can also look at the posterior variance of theta
theta_var <- var(posterior_theta)
print(theta_var)
# We can also continue the ABC-SMC-RF run if the posterior convergence is not satisfactory
smcrf_results <- smcrf(
    method = "smcrf-single-param",
    smcrf_results = smcrf_results,
    model = model,
    perturb = perturb,
    bounds = bounds,
    nParticles = c(1000, 1000)
)
# We look again at the posterior mean and variance of theta
posterior_iteration <- paste0("Iteration_", (smcrf_results$nIterations + 1))
posterior_theta <- smcrf_results[[posterior_iteration]]$parameters$theta
theta_mean <- mean(posterior_theta)
print(theta_mean)
theta_var <- var(posterior_theta)
print(theta_var)
# and notice that while the mean doesn't change much, the variance decreases, signifying higher certainty
#---------------------ABC-SMC-RF for a model with multiple parameters
#    Data to be fitted, consisting of two statistics s1 and s2:
statistics_target <- data.frame(s1 = 4, s2 = 4)
#    Parametrized model for the statistics:
model <- function(parameters) {
    statistics <- data.frame(
        s1 = parameters$mu + parameters$theta + runif(nrow(parameters)),
        s2 = parameters$mu * parameters$theta + runif(nrow(parameters))
    )
    cbind(parameters, statistics)
}
#    Function to perturb the parameters with random noise:
perturb <- function(parameters) {
    if (any(grepl("theta", colnames(parameters)))) {
        parameters[["theta"]] <- parameters[["theta"]] + runif(nrow(parameters), min = -0.1, max = 0.1)
    } else if (any(grepl("mu", colnames(parameters)))) {
        parameters[["mu"]] <- parameters[["mu"]] + runif(nrow(parameters), min = -0.1, max = 0.1)
    }
    return(parameters)
}
#    Initial guesses for the parameter theta:
parameters_initial <- data.frame(
    theta = runif(100000, -10, 10),
    mu = runif(100000, -10, 10)
)
#    Make sure that theta stays within bounds of prior distribution:
bounds <- data.frame(
    parameter = c("theta", "mu"),
    min = c(-10, -10),
    max = c(10, 10)
)
#    Run ABC-SMC-RF:
smcrf_results <- smcrf(
    method = "smcrf-single-param",
    statistics_target = statistics_target,
    model = model,
    perturb = perturb,
    bounds = bounds,
    parameters_initial = parameters_initial,
    nParticles = c(1000, 1000, 1000),
)
#    Get the posterior means of parameters:
posterior_iteration <- paste0("Iteration_", (smcrf_results$nIterations + 1))
posterior_params <- smcrf_results[[posterior_iteration]]$parameters
posterior_means <- colMeans(posterior_params)
#    Get the posterior covariance matrix of parameters:
posterior_vars <- var(posterior_params)
#--------------------------------ABC-SMC-DRF for a multivariate model
#   Data to be fitted, consisting of three statistics s1, s2, and s3:
statistics_target <- data.frame(s1 = 9, s2 = 18, s3 = 3)
#    Parametrized model for the statistics:
model <- function(parameters) {
    statistics <- data.frame(
        s1 = parameters$mu + parameters$theta + runif(nrow(parameters)),
        s2 = parameters$mu * parameters$theta + runif(nrow(parameters))
    )
    cbind(parameters, statistics)
}
#    Function to perturb the parameters with random noise:
perturb <- function(parameters) {
    if (any(grepl("theta", colnames(parameters)))) {
        parameters[["theta"]] <- parameters[["theta"]] + runif(nrow(parameters), min = -0.1, max = 0.1)
    } else if (any(grepl("mu", colnames(parameters)))) {
        parameters[["mu"]] <- parameters[["mu"]] + runif(nrow(parameters), min = -0.1, max = 0.1)
    }
    return(parameters)
}
#    Initial guesses for the parameter theta:
theta <- runif(100000, -10, 10)
parameters_initial <- data.frame(
    theta = theta,
    mu = theta * 2
)
#    Make sure that theta stays within bounds of prior distribution:
bounds <- data.frame(
    parameter = c("theta", "mu"),
    min = c(-10, -10),
    max = c(10, 10)
)
#    Run ABC-SMC-DRF:
smcrf_results <- smcrf(
    method = "smcrf-multi-param",
    statistics_target = statistics_target,
    model = model,
    perturb = perturb,
    bounds = bounds,
    parameters_initial = parameters_initial,
    nParticles = c(1000, 1000, 1000),
)
#    Get the posterior means of parameters:
posterior_iteration <- paste0("Iteration_", (smcrf_results$nIterations + 1))
posterior_params <- smcrf_results[[posterior_iteration]]$parameters
posterior_means <- colMeans(posterior_params)
#    Get the posterior covariance matrix of parameters:
posterior_vars <- var(posterior_params)
#    If the posterior distribution has not converged, we can continue the ABC-SMC-DRF run:
smcrf_results <- smcrf(
    method = "smcrf-multi-param",
    model = model,
    perturb = perturb,
    bounds = bounds,
    nParticles = c(1000, 1000),
)
}
